////////////////////////////////////////////////////////////////////////////////
//
// (C) Andy Thomason 2017
//
// 

#ifndef ANDYZIP_HUFFMAN_TABLE_HPP_
#define ANDYZIP_HUFFMAN_TABLE_HPP_

#include <cstdint>
#include <utility>

namespace andyzip {
  template<int MaxCodes, bool debug = false>
  class huffman_table {
    uint8_t min_length_;
    uint8_t max_length_;

    uint16_t symbols_[MaxCodes];
    uint16_t limits_[18];
    uint16_t base_[18];

    bool invalid_;

    static uint16_t rev16(uint16_t value) {
      static const uint8_t r256[] = {
        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 
        0x00+0x10, 0x80+0x10, 0x40+0x10, 0xc0+0x10, 0x20+0x10, 0xa0+0x10, 0x60+0x10, 0xe0+0x10, 
        0x00+8, 0x80+8, 0x40+8, 0xc0+8, 0x20+8, 0xa0+8, 0x60+8, 0xe0+8, 
        0x00+0x10+8, 0x80+0x10+8, 0x40+0x10+8, 0xc0+0x10+8, 0x20+0x10+8, 0xa0+0x10+8, 0x60+0x10+8, 0xe0+0x10+8, 
        0x00+ 4, 0x80+ 4, 0x40+ 4, 0xc0+ 4, 0x20+ 4, 0xa0+ 4, 0x60+ 4, 0xe0+ 4, 
        0x00+0x10+ 4, 0x80+0x10+ 4, 0x40+0x10+ 4, 0xc0+0x10+ 4, 0x20+0x10+ 4, 0xa0+0x10+ 4, 0x60+0x10+ 4, 0xe0+0x10+ 4, 
        0x00+8+ 4, 0x80+8+ 4, 0x40+8+ 4, 0xc0+8+ 4, 0x20+8+ 4, 0xa0+8+ 4, 0x60+8+ 4, 0xe0+8+ 4, 
        0x00+0x10+8+ 4, 0x80+0x10+8+ 4, 0x40+0x10+8+ 4, 0xc0+0x10+8+ 4, 0x20+0x10+8+ 4, 0xa0+0x10+8+ 4, 0x60+0x10+8+ 4, 0xe0+0x10+8+ 4, 
        0x00+ 2, 0x80+ 2, 0x40+ 2, 0xc0+ 2, 0x20+ 2, 0xa0+ 2, 0x60+ 2, 0xe0+ 2, 
        0x00+0x10+ 2, 0x80+0x10+ 2, 0x40+0x10+ 2, 0xc0+0x10+ 2, 0x20+0x10+ 2, 0xa0+0x10+ 2, 0x60+0x10+ 2, 0xe0+0x10+ 2, 
        0x00+8+ 2, 0x80+8+ 2, 0x40+8+ 2, 0xc0+8+ 2, 0x20+8+ 2, 0xa0+8+ 2, 0x60+8+ 2, 0xe0+8+ 2, 
        0x00+0x10+8+ 2, 0x80+0x10+8+ 2, 0x40+0x10+8+ 2, 0xc0+0x10+8+ 2, 0x20+0x10+8+ 2, 0xa0+0x10+8+ 2, 0x60+0x10+8+ 2, 0xe0+0x10+8+ 2, 
        0x00+ 4+ 2, 0x80+ 4+ 2, 0x40+ 4+ 2, 0xc0+ 4+ 2, 0x20+ 4+ 2, 0xa0+ 4+ 2, 0x60+ 4+ 2, 0xe0+ 4+ 2, 
        0x00+0x10+ 4+ 2, 0x80+0x10+ 4+ 2, 0x40+0x10+ 4+ 2, 0xc0+0x10+ 4+ 2, 0x20+0x10+ 4+ 2, 0xa0+0x10+ 4+ 2, 0x60+0x10+ 4+ 2, 0xe0+0x10+ 4+ 2, 
        0x00+8+ 4+ 2, 0x80+8+ 4+ 2, 0x40+8+ 4+ 2, 0xc0+8+ 4+ 2, 0x20+8+ 4+ 2, 0xa0+8+ 4+ 2, 0x60+8+ 4+ 2, 0xe0+8+ 4+ 2, 
        0x00+0x10+8+ 4+ 2, 0x80+0x10+8+ 4+ 2, 0x40+0x10+8+ 4+ 2, 0xc0+0x10+8+ 4+ 2, 0x20+0x10+8+ 4+ 2, 0xa0+0x10+8+ 4+ 2, 0x60+0x10+8+ 4+ 2, 0xe0+0x10+8+ 4+ 2, 
        0x00+ 1, 0x80+ 1, 0x40+ 1, 0xc0+ 1, 0x20+ 1, 0xa0+ 1, 0x60+ 1, 0xe0+ 1, 
        0x00+0x10+ 1, 0x80+0x10+ 1, 0x40+0x10+ 1, 0xc0+0x10+ 1, 0x20+0x10+ 1, 0xa0+0x10+ 1, 0x60+0x10+ 1, 0xe0+0x10+ 1, 
        0x00+8+ 1, 0x80+8+ 1, 0x40+8+ 1, 0xc0+8+ 1, 0x20+8+ 1, 0xa0+8+ 1, 0x60+8+ 1, 0xe0+8+ 1, 
        0x00+0x10+8+ 1, 0x80+0x10+8+ 1, 0x40+0x10+8+ 1, 0xc0+0x10+8+ 1, 0x20+0x10+8+ 1, 0xa0+0x10+8+ 1, 0x60+0x10+8+ 1, 0xe0+0x10+8+ 1, 
        0x00+ 4+ 1, 0x80+ 4+ 1, 0x40+ 4+ 1, 0xc0+ 4+ 1, 0x20+ 4+ 1, 0xa0+ 4+ 1, 0x60+ 4+ 1, 0xe0+ 4+ 1, 
        0x00+0x10+ 4+ 1, 0x80+0x10+ 4+ 1, 0x40+0x10+ 4+ 1, 0xc0+0x10+ 4+ 1, 0x20+0x10+ 4+ 1, 0xa0+0x10+ 4+ 1, 0x60+0x10+ 4+ 1, 0xe0+0x10+ 4+ 1, 
        0x00+8+ 4+ 1, 0x80+8+ 4+ 1, 0x40+8+ 4+ 1, 0xc0+8+ 4+ 1, 0x20+8+ 4+ 1, 0xa0+8+ 4+ 1, 0x60+8+ 4+ 1, 0xe0+8+ 4+ 1, 
        0x00+0x10+8+ 4+ 1, 0x80+0x10+8+ 4+ 1, 0x40+0x10+8+ 4+ 1, 0xc0+0x10+8+ 4+ 1, 0x20+0x10+8+ 4+ 1, 0xa0+0x10+8+ 4+ 1, 0x60+0x10+8+ 4+ 1, 0xe0+0x10+8+ 4+ 1, 
        0x00+ 2+ 1, 0x80+ 2+ 1, 0x40+ 2+ 1, 0xc0+ 2+ 1, 0x20+ 2+ 1, 0xa0+ 2+ 1, 0x60+ 2+ 1, 0xe0+ 2+ 1, 
        0x00+0x10+ 2+ 1, 0x80+0x10+ 2+ 1, 0x40+0x10+ 2+ 1, 0xc0+0x10+ 2+ 1, 0x20+0x10+ 2+ 1, 0xa0+0x10+ 2+ 1, 0x60+0x10+ 2+ 1, 0xe0+0x10+ 2+ 1, 
        0x00+8+ 2+ 1, 0x80+8+ 2+ 1, 0x40+8+ 2+ 1, 0xc0+8+ 2+ 1, 0x20+8+ 2+ 1, 0xa0+8+ 2+ 1, 0x60+8+ 2+ 1, 0xe0+8+ 2+ 1, 
        0x00+0x10+8+ 2+ 1, 0x80+0x10+8+ 2+ 1, 0x40+0x10+8+ 2+ 1, 0xc0+0x10+8+ 2+ 1, 0x20+0x10+8+ 2+ 1, 0xa0+0x10+8+ 2+ 1, 0x60+0x10+8+ 2+ 1, 0xe0+0x10+8+ 2+ 1, 
        0x00+ 4+ 2+ 1, 0x80+ 4+ 2+ 1, 0x40+ 4+ 2+ 1, 0xc0+ 4+ 2+ 1, 0x20+ 4+ 2+ 1, 0xa0+ 4+ 2+ 1, 0x60+ 4+ 2+ 1, 0xe0+ 4+ 2+ 1, 
        0x00+0x10+ 4+ 2+ 1, 0x80+0x10+ 4+ 2+ 1, 0x40+0x10+ 4+ 2+ 1, 0xc0+0x10+ 4+ 2+ 1, 0x20+0x10+ 4+ 2+ 1, 0xa0+0x10+ 4+ 2+ 1, 0x60+0x10+ 4+ 2+ 1, 0xe0+0x10+ 4+ 2+ 1, 
        0x00+8+ 4+ 2+ 1, 0x80+8+ 4+ 2+ 1, 0x40+8+ 4+ 2+ 1, 0xc0+8+ 4+ 2+ 1, 0x20+8+ 4+ 2+ 1, 0xa0+8+ 4+ 2+ 1, 0x60+8+ 4+ 2+ 1, 0xe0+8+ 4+ 2+ 1, 
        0x00+0x10+8+ 4+ 2+ 1, 0x80+0x10+8+ 4+ 2+ 1, 0x40+0x10+8+ 4+ 2+ 1, 0xc0+0x10+8+ 4+ 2+ 1, 0x20+0x10+8+ 4+ 2+ 1, 0xa0+0x10+8+ 4+ 2+ 1, 0x60+0x10+8+ 4+ 2+ 1, 0xe0+0x10+8+ 4+ 2+ 1, 
      };
      return r256[value&0xff] << 8 | r256[(value>>8)&0xff];
    }
  public:
    static const int max_codes = MaxCodes;

    void init(const uint8_t *lengths, const uint16_t *symbols, unsigned num_lengths) {
      invalid_ = true;

      min_length_ = 16;
      max_length_ = 0;
      for (unsigned i = 0; i != num_lengths; ++i) {
        if (debug) printf("%d,", lengths[i]);
        if (lengths[i]) {
          if (min_length_ > lengths[i]) min_length_ = lengths[i];
          if (max_length_ < lengths[i]) max_length_ = lengths[i];
        }
      }
      if (debug) printf("\n");

      if (debug) printf("min_length_=%d\n", min_length_);
      if (debug) printf("max_length_=%d\n", max_length_);

      if ( min_length_ <= 0 || min_length_ > max_length_ || max_length_ > 16 ) {
        return;
      }

      unsigned code = 0;
      unsigned huffcode = 0;
      for (unsigned length = min_length_; length <= max_length_; ++length) {
        base_[length-min_length_] = huffcode - code;
        for (unsigned i = 0; i != num_lengths; ++i) {
          if (lengths[i] == length) {
            symbols_[code++] = symbols[i];
            //dump_bits(huffcode << (16-length), 16, "huffcode");
            huffcode++;
          }
        }
        limits_[length-min_length_] = (uint16_t)( ( huffcode << (16-length) ) - 1 );
        if (debug) printf("length %d: lim=%04x base_=%04x\n", length, ( huffcode << (16-length) ) - 1, base_[length-min_length_]);
        if (( huffcode << (16-length) ) - 1 > 0xffff) {
          if (debug) printf("invalid huffman table\n");
          return;
        }
        huffcode *= 2;
      }

      // prevent escape from bitstream decoding loop.
      limits_[max_length_+1-min_length_] = 0xffff;
      invalid_ = false;
    }

    bool invalid() const { return invalid_; }


    std::pair<unsigned, unsigned> decode(unsigned peek16) {
      unsigned value = rev16(peek16);
      unsigned index = 0;
      while (value > limits_[index]) {
        index++;
      }
      unsigned length = min_length_ + index;
      unsigned offset = ( value >> ( 16 - length ) );
      unsigned code = symbols_[offset - base_[index]];
      return std::make_pair(length, code);
    }
  };
}

#endif
